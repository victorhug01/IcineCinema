Descrição das classes da Bomboniere (namespace Icine\Sistema)

1) Produto (abstrata)
- Propósito: Representa a entidade base para itens que podem ser vendidos na bomboniere.
- Propriedades: codigo (string), nome (string), preco (float)
- Métodos principais:
  - __construct(string $codigo, string $nome, float $preco)
  - getCodigo(): string
  - getNome(): string
  - setNome(string $nome): void
  - getPreco(): float
  - setPreco(float $preco): void
  - descricao(): string (abstract)
  - calcularPreco(): float
- Observações: Define a interface mínima e comportamento padrão (calcularPreco retorna o preco). Subclasses estendem e sobrescrevem descricao() e podem sobrescrever calcularPreco() (polimorfismo).

2) Comida (extends Produto)
- Propósito: Representa produtos alimentícios (salgados, doces, etc.).
- Propriedades adicionais: tipo (?string)
- Comportamento específico:
  - descricao(): string — formata o nome e o tipo
  - calcularPreco(): float — aplica um desconto fixo simbólico (5%) sobre o preço base

3) Bebida (extends Produto)
- Propósito: Representa bebidas vendidas na bomboniere.
- Propriedades adicionais: volume (float, ml), alcoolica (bool)
- Comportamento específico:
  - descricao(): string — formata nome, volume e indica se é alcoólica
  - calcularPreco(): float — aplica um acréscimo de 10% se for alcoólica

4) ItemEstoque
- Propósito: Representa um produto no estoque com a quantidade disponível.
- Propriedades: produto (Produto), quantidade (int)
- Métodos:
  - __construct(Produto $produto, int $quantidade = 0)
  - getProduto(): Produto
  - getQuantidade(): int
  - setQuantidade(int $q): void
  - aumentar(int $q): void
  - reduzir(int $q): bool — decrementa se houver estoque suficiente e retorna true; caso contrário, false

5) Estoque
- Propósito: Gerencia um conjunto de ItemEstoque, permitindo operações CRUD e alteração de quantidades.
- Implementação: mantém um array associativo de ItemEstoque indexado por código do produto
- Métodos principais:
  - cadastrarProduto(Produto $produto, int $quantidade = 0): void
  - editarProduto(string $codigo, array $dados): bool — altera nome, preco e quantidade quando fornecidos
  - removerProduto(string $codigo): bool
  - listarProdutos(): ItemEstoque[]
  - obterProduto(string $codigo): ?ItemEstoque
  - reduzirQuantidade(string $codigo, int $q): bool

6) Venda
- Propósito: Representa uma transação de venda realizada na bomboniere.
- Propriedades: id (string), produto (Produto), quantidade (int), total (float), data (DateTimeImmutable)
- Comportamento: calcula o total com base em produto->calcularPreco() e na quantidade.

7) Bomboniere
- Propósito: Controlador que usa Estoque para cadastrar/editar/excluir/listar produtos e efetuar vendas (cria objetos Venda).
- Propriedade: estoque (Estoque) e array de vendas
- Métodos:
  - cadastrarProduto(Produto $produto, int $quantidade = 0): void
  - editarProduto(string $codigo, array $dados): bool
  - excluirProduto(string $codigo): bool
  - listarProdutos(): ItemEstoque[]
  - vender(string $codigo, int $quantidade): ?Venda — verifica estoque, reduz quantidade e cria Venda
  - getVendas(): Venda[]

Como usar (exemplo CLI no index.php):
- Inicializar:
  $estoque = new Estoque();
  $bomboniere = new Bomboniere($estoque);
- Cadastrar uma comida:
  $c = new Comida('c001', 'Coxinha', 6.50, 'salgado');
  $bomboniere->cadastrarProduto($c, 10);
- Vender 2 unidades:
  $v = $bomboniere->vender('c001', 2);
  if ($v !== null) echo $v->getTotal();

Observações finais:
- Encapsulamento: propriedades são privadas e só acessíveis por getters/setters.
- Herança: Comida e Bebida estendem Produto.
- Abstração: Produto é abstrata e obriga descricao() nas subclasses.
- Polimorfismo: calcularPreco() pode ser sobrescrito pelas subclasses para alterar o preço final.

Arquivo gerado automaticamente pelo assistente para documentar as classes da bomboniere.

Mapeamento de opções do menu (implementação em `index.php`):

- Menu Bomboniere:
  1) Cadastrar produto
    - Fluxo: lê inputs via `rl()` (wrapper de `readline`), realiza casts (`(float)`, `(int)`) quando necessário.
    - Instancia `Comida` ou `Bebida` conforme escolha e chama `Bomboniere::cadastrarProduto($produto, $quantidade)`.
    - Internamente: `Bomboniere::cadastrarProduto` delega para `Estoque::cadastrarProduto`, que insere um `ItemEstoque` no array associativo `$itens` indexado pelo código.

  2) Editar produto
    - Fluxo: solicita o `codigo` e campos opcionais; constrói um array `$dados` com chaves `nome`, `preco`, `quantidade` quando preenchidos.
    - Chama `Bomboniere::editarProduto($codigo, $dados)`.
    - Internamente: `Bomboniere::editarProduto` chama `Estoque::editarProduto($codigo, $dados)`, que busca o `ItemEstoque` no array e aplica setters no `Produto` e/ou quantidade no `ItemEstoque`.

  3) Excluir produto
    - Fluxo: solicita o `codigo` e chama `Bomboniere::excluirProduto($codigo)`.
    - Internamente: `Bomboniere::excluirProduto` chama `Estoque::removerProduto($codigo)`, que utiliza `unset($this->itens[$codigo])` para remover do array.

  4) Listar produtos
    - Fluxo: chama `Bomboniere::listarProdutos()`.
    - Internamente: `Bomboniere::listarProdutos` delega para `Estoque::listarProdutos()`, que retorna `array_values($this->itens)` (array de `ItemEstoque`).

  5) Vender produto
    - Fluxo: solicita `codigo` e `quantidade` (com cast para `int`) e chama `Bomboniere::vender($codigo, $quantidade)`.
    - Internamente: `Bomboniere::vender` obtém o `ItemEstoque` via `Estoque::obterProduto`, verifica quantidade, chama `ItemEstoque::reduzir($quantidade)` para decrementar o estoque e, se bem-sucedido, cria um objeto `Venda` e o registra no array privado `$vendas` da `Bomboniere`.

  6) Voltar
    - Fluxo: retorna ao menu principal (não envolve operações de bomboniere).

Observações técnicas sobre a implementação CLI:
- A função `rl(string $prompt): string` em `index.php` encapsula `readline()` e normaliza a entrada (retornando string vazia quando `readline` retorna `false`).
- Em vários pontos são usados type castings explícitos vindos de `readline`, por exemplo `(int) rl(...)` e `(float) rl(...)`, satisfazendo o requisito de uso de casts.
- Arrays: o `Estoque` usa um array associativo (`private array $itens`) para armazenar `ItemEstoque`, e `Bomboniere` mantém um array de vendas (`private array $vendas`).

Checklist de requisitos (status atual):
- PHP: atendido (código em PHP, `declare(strict_types=1)` presente).
- Composer: atendido (`composer.json` presente e `vendor/autoload.php` utilizado em `index.php`).
- POO (abstração, herança, encapsulamento, polimorfismo): atendido (ex.: `Produto` é abstrata, `Comida`/`Bebida` estendem, propriedades privadas + getters/setters, `calcularPreco()` polimórfico).
- CLI com `readline`: atendido (função `rl` em `index.php`).
- Type castings para entrada: atendido (vários casts `(int)`, `(float)` no `index.php`).
- Opções para cadastrar/editar/excluir objetos: atendido (menu da Bomboniere em `index.php` chama métodos correspondentes).
- Uso de arrays: atendido (`Estoque::$itens`, `Bomboniere::$vendas`, uso de arrays para dados de edição etc.).
- Mínimo de 7 classes: atendido (há 14 arquivos de classe em `src/`).

Sugestões (opcionais):
- Documentar no `README.md` os comandos para executar o CLI: por exemplo, `php index.php` e requisitos (PHP versão mínima, Composer autoload já gerado).
- Adicionar validações/tratamento de erros nos inputs (ex.: valores negativos, código duplicado) caso queira fortalecer robustez.
